---
layout:     post
title:      From Finger Gymnastics To Chain-of-Thought
date:       2024-09-07 00:00:00
summary:    Evolution of programmers' productivity tools 
categories: artificial intelligence, decision making, strategic thinking, change management
---

## Vim to Cursor

The creator of VIM, Bram Moolenaar, passed away on 3rd of August, 2023. In the same year, Cursor, one of the most
popular AI IDEs today, raised $20 million in Series A funding, after it had been founded for one year. Before the
AI-assisted development tool arose, programmers had "respected" those who are able to code fast with their fingers, and
considered it as a sign of coding prowess. When I firstly saw my senior programmer typing code without leaving his
keyboard, I was amazed. It was so cool that he typed codes just like the hackers in the movies.

Today, the coolest way of programming seems no longer to be typing codes with hotkeys completely on the keyboard, but to
be merely clicking "tab" and "enter" to generate codes with AI - tab to autocomplete and enter to generate/accept. This
is thanks to the proliferation of the large language models (LLMs) that are used for coding efficiency improvement.

After my amazement, I started to wonder: what are the implications of this new programming paradigm? What are the pros and cons?

## What do we gain and what do we lose?

### The gain is very observable

This is what I usually do when I am working on coding activities as a machine learning engineer without AI. 

1. Get a request of application or a feature from the client or the product manager.
1. Think about what I want to do, and how to do it. 
1. Open my IDE (without a loss of my heavy preference for VIM, I use VSCode with Vim emulation plugin).
1. Draw some sketches about what the code should look like - usually I do this with `mermaid` or `draw.io`.
1. Write down the thoughts into markdown files.
1. Design and develop the structure of the code. Not actual code yet, but just the scaffolding.
1. Write the high-level interface and base classes.
1. Write the actual functions and classes. I am a data scientist but I don't write in Jupyter notebook. My codes directly
1. Write the unit tests.
1. Develop/refine the CI/CD pipeline. I use Github Actions or Azure DevOps.
1. Deploy the application or feature.

To accelerate the development process above, I have my own code base where there are many components that can be reused.
For example, I have a code base for data processing, a code base for model development, a code base for deployment, and
so on. I put efforts into refining these code bases so that I can save more time for the development of the new feature.
But still, for any brand-new applications, I have to write lots of codes manually, particular, the **tests**.

With the AI-assisted coding...

I can probably just need to do the first three steps. This leads to a significant gain of efficiency in the development
process. Moreover, I am not a full-stack programmer, so I can just focus on the interface and the core of the
application. I don't need to care about the programming language, the framework, nor the low-level details!

Well, the gain is not just for me. It is for nearly everyone that wants to develop software without a thorough
understanding of the low-level coding details. And amazingly, we saw the fantastic work from even kids who used AI to
generate codes for their projects (see below). With the adoption of the AI-assisted coding, the number of potential
programmers (e.g., non-computer science, non-engineering students) has increased dramatically. And truly building
software application has been democratized. And it's no longer the privilege of the computer science students or the
engineering professionals any more! 

<iframe width="560" height="315" src="https://www.youtube.com/embed/o5uvDZ8srHA" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>

**But is it all good**?

### Emotional fulfillment as a programmer may not be there

**AI makes human programmers lazier and less cool**. 

![AI-assisted coding](https://compote.slate.com/images/fe8e6b45-1ea0-45db-ade4-7ce00647041b.jpeg?crop=1560%2C1040%2Cx0%2Cy0&width=840)
<font size="1">The character of a human in the movie "WALL-E". It pictures the futuristic human outlook when AI can do everything for humans. And due to that, the human becomes lazy and fat.</font>

After my initial excitement, I started to think about the implications of the AI-assisted coding. One significant aspect
that may be lost in the transition to AI-assisted coding is the emotional fulfillment. I became "lazy" to work on a
Vim-like environment any more after I found that an AI IDE like Cursor can generate codes for me with just typing "tab"
and "enter". 

One significant aspect that may be lost in the transition to AI-assisted coding is *the emotional fulfillment and
psychological satisfaction that many programmers derive from the traditional coding process*. The act of manually
crafting code, line by line, can be deeply rewarding. It's a process that engages the mind, challenges problem-solving
skills, and provides a sense of accomplishment when complex algorithms are successfully implemented. This hands-on
approach allows developers to feel a strong connection to their work, fostering a sense of ownership and pride in the
final product.

The AI-based tool also diminishes my "pride" as a Vim programmer. Indeed, I can do things faster with auto-completion
but, that is not the coolness of me - it is that of the AI models. I may not be respected any more as a programmer that
can code fast with Vim - I am simply downgraded to be equivalent to an AI model that is tuned to just generate codes for
me. 

The picture below shows the IDE experience with VIM and its plugin, called `nerdtree`. See reference  
[here](https://vimawesome.com/plugin/git-nerdtree) (it was created by
[@jistr](https://github.com/jistr) 10 years ago!).

![Vim IDE Setup by using nerdtree, airline, ctrlp and vim-startify](https://i.imgur.com/jSCwGjU.gif?1)

To achieve the above, assuming the plugin of `nerdtree` is installed, you can use the following steps:

Place this in your .vimrc:

```vim
Plugin 'xuyuanp/git-nerdtree'
```

then run the following in Vim:

```vim
:source %
:PluginInstall
```

Now this may be treated as a quite "manual" and "tedious" way of coding because
AI can do everything for us. But the fulfillment of joy from configuring a Vim
IDE lasts much longer than that from developing an application with Cursor. 

While my fulfillment is from the use of the IDE for coding my own application,
other programmers may have their own fulfillment from other things. For example,
some may find fulfillment from finding a more beautiful pattern to design a data
access layer, implementing a new algorithm with lower time complexity compared
to the state-of-the-art, or optimizing the data pipeline efficiency by
introducing proper partition in the database tables. All of these joys, with the
use of AI-based tool, may be gone, because they don't need to and perhaps, don't
want to think about these things. 

And this leads to the next point - AI programming tools may gradually erode
programmers' pursuit of technical depth and details without them realizing it.

### No more need for in-depth understanding about the low-level details

While AI-based coding tools have revolutionized the programming landscape, they
also introduce a potential disconnect between programmers and the underlying
systems they work with. This abstraction, while beneficial for rapid
development, may lead to a superficial understanding of programming concepts and
system architecture.

One of the primary concerns is the potential loss of performance optimization
skills. Traditional programming practices often require developers to have a
deep understanding of memory management, CPU architecture, and algorithmic
efficiency. This knowledge allows them to write code that not only functions
correctly but also performs optimally. AI-generated code, while functional, may
not always be the most efficient solution, especially for complex or
resource-intensive applications.

Moreover, the abstraction provided by AI coding tools may hinder a programmer's
ability to debug effectively. When issues arise, especially those related to
performance or unexpected behavior, a solid grasp of low-level details becomes
crucial. Programmers who rely heavily on AI-generated code may find themselves
ill-equipped to diagnose and resolve such problems, potentially leading to
increased development time and suboptimal solutions.

Another consideration is the impact on innovation and advancement in computer
science. Many groundbreaking developments in programming languages, frameworks,
and systems have come from developers who deeply understood the intricacies of
computer architecture. By removing the need for this knowledge, we risk stifling
innovation in these fundamental areas, potentially slowing the overall progress
of computer science and software engineering.

Lastly, there's a concern about the long-term sustainability of software
development as a profession. As AI tools become more sophisticated, there's a
risk of creating a generation of programmers who are overly dependent on these
tools and lack the foundational knowledge to adapt to new technologies or solve
novel problems. This could lead to a widening gap between AI-assisted
programmers and those with deep technical expertise, potentially reshaping the
job market and the nature of software development roles.

### How do programmers talk to the AI tools with responsibility and accountability?

I have to say, the debugging experience for AI-generated code is not there yet.
Particularly, I am working in the data science domain, where domain knowledge
plays a crucial role. Relying on AI tools to generate code without fully
understanding the underlying mechanisms can be challenging. The current practice
of programming with AI assistants is done in a black-box manner, where the
programmer inputs a prompt and the AI tool generates code. 

AI-based approach:
<!DOCTYPE html>
<html lang="en">
   <head>
	 <script src="https://cdnjs.cloudflare.com/ajax/libs/mermaid/8.0.0/mermaid.min.js"></script>
    </head>
	 
<div class="mermaid">
graph TD
    A[Programmer] -->|"Prompt"| B[AI Assistant]
    B -->|"Code"| C[Machine]
    C -->|"Bug"| A
    C -->|"Fix"| E[Solution]
</div>
	
</body>
<script>
var config = {
    startOnLoad:true,
    theme: 'forest',
    flowchart:{
            useMaxWidth:false,
            htmlLabels:true
        }
};
mermaid.initialize(config);
window.mermaid.init(undefined, document.querySelectorAll('.language-mermaid'));
</script>

</html>

Classic approach:
<!DOCTYPE html>
<html lang="en">
   <head>
	 <script src="https://cdnjs.cloudflare.com/ajax/libs/mermaid/8.0.0/mermaid.min.js"></script>
    </head>
	 
<div class="mermaid">
graph TD
    A[Programmer] -->|"Code"| B[Machine]
    B -->|"Bug"| A
    B -->|"Fix"| E[Solution]
</div>
	
</body>
<script>
var config = {
    startOnLoad:true,
    theme: 'forest',
    flowchart:{
            useMaxWidth:false,
            htmlLabels:true
        }
};
mermaid.initialize(config);
window.mermaid.init(undefined, document.querySelectorAll('.language-mermaid'));
</script>

</html>

The debugging process for the AI-based approach and the conventional approach are different. In the AI-based approach,
the programmer is not directly involved in the debugging process. The AI assistant is the one that fixes the bug. In the
conventional approach, the programmer is the one that fixes the bug. So the bug may arise in multiple places, and it is
not clear which part of the code is causing the bug. It is worth noting that the impact of such difference is even
higher in the code development for data science applications, reason being that the codes involve facts that may not be
known to the AI assistant but known to the programmer/domain expert. Hence, without the required knowledge, the AI
assistant would not be able to fix the bug that may be due to incorrect data or incorrect assumptions, and the ideas
generated from the AI assistant may not be able to solve the problem correctly.

## What can be done?
